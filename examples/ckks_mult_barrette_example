from ckks.ckks_parameters import CKKSParameters
from ckks.ckks_key_generator import CKKSKeyGenerator
from ckks.ckks_encoder import CKKSEncoder
from ckks.ckks_encryptor import CKKSEncryptor
from ckks.ckks_decryptor import CKKSDecryptor
from ckks.ckks_evaluator import CKKSEvaluator

# Parameters: (from your example)
poly_degree = 8
ciph_modulus = 1 << 60
big_modulus = 1 << 120
scaling_factor = 1 << 30

params = CKKSParameters(
    poly_degree=poly_degree,
    ciph_modulus=ciph_modulus,
    big_modulus=big_modulus,
    scaling_factor=scaling_factor
)

# Key generation
keygen = CKKSKeyGenerator(params)
public_key = keygen.public_key
secret_key = keygen.secret_key
relin_key = keygen.relin_key

# Encoder, Encryptor, Evaluator, Decryptor
encoder = CKKSEncoder(params)
encryptor = CKKSEncryptor(params, public_key)
decryptor = CKKSDecryptor(params, secret_key)
evaluator = CKKSEvaluator(params)

# Complex message vectors
message1 = [0.5, 0.3 + 0.2j, 0.78, 0.88j]
message2 = [0.2, 0.11, 0.4 + 0.67j, 0.9 + 0.99j]

# Encode
plain1 = encoder.encode(message1, scaling_factor)  # converts to integer poly coefficients
plain2 = encoder.encode(message2, scaling_factor)

# Encrypt (applies Barrett reduction via Polynomial code)
ciph1 = encryptor.encrypt(plain1)
ciph2 = encryptor.encrypt(plain2)

# Homomorphic multiply (uses Barrett reduction after multiplication/rescale)
ciph_prod = evaluator.multiply(ciph1, ciph2, relin_key)

# Decrypt (uses Barrett reduction in polynomial addition, modular reduction)
decrypted_prod = decryptor.decrypt(ciph_prod)

# Decode (back into complex vector)
decoded_prod = encoder.decode(decrypted_prod)

print("Multiplicative CKKS Example with Barrett Reducer:")
print("Input 1:", message1)
print("Input 2:", message2)
print("Decrypted (approx):", [complex(round(x.real,3), round(x.imag,3)) for x in decoded_prod])
